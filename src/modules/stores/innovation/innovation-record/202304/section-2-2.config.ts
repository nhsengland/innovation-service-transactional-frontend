import { FormEngineModel, WizardEngineModel, WizardStepType, WizardSummaryType } from '@modules/shared/forms';

import { sectionType } from '../shared.types';

import { InnovationSections } from './catalog.types';
import { DocumentType202304 } from './document.types';
import { evidenceSubmitTypeItems, needsSupportAnyAreaItems, yesNoItems, yesNotYetItems } from './forms.config';
import { SECTION_2_EVIDENCES } from './section-2-2-evidences.config';


// Labels.
const stepsLabels = {
  q1: { label: 'Do you have any evidence to show the impact or benefits of your innovation?' },
  q2: { label: 'Are you currently collecting evidence, or have plans to collect evidence?' },
  q3: {
    label: 'Write a short summary of your ongoing or planned evidence gathering, including the IRAS number if known.',
    description: `An IRAS ID is a unique identifier, which is generated by IRAS when you first create a project. It is the accepted common study identifier, allowing research to be traced across its study lifecycle. For more information visit the <a href="https://www.myresearchproject.org.uk" target="_blank" rel="noopener noreferrer">IRAS website (opens in new window)</a>.`
  },
  q4: { label: 'Upload any documents relevant to this evidence collection', description: 'Files must be CSV, XLSX, DOCX or PDF, and can be up to 20MB each.' },
  q5: { label: 'Do you need support with any of these areas?' }
};


// Types.
type InboundPayloadType = Omit<DocumentType202304['EVIDENCE_OF_IMPACT'], 'files'> & { files?: { id: string; name: string, url: string }[] };
type StepPayloadType = InboundPayloadType;
type OutboundPayloadType = DocumentType202304['EVIDENCE_OF_IMPACT'];

// Logic.
export const SECTION_2_2: sectionType<InnovationSections> = {
  id: 'EVIDENCE_OF_IMPACT',
  title: 'Evidence of impact and benefit',
  wizard: new WizardEngineModel({
    steps: [
      new FormEngineModel({
        parameters: [{
          id: 'hasEvidence', dataType: 'radio-group', label: stepsLabels.q1.label,
          validations: { isRequired: [true, 'Choose one option'] },
          items: yesNotYetItems
        }]
      })
    ],
    showSummary: true,
    runtimeRules: [(steps: WizardStepType[], currentValues: StepPayloadType, currentStep: number | 'summary') => runtimeRules(steps, currentValues, currentStep)],
    // inboundParsing: (data: InboundPayloadType) => inboundParsing(data),
    outboundParsing: (data: StepPayloadType) => outboundParsing(data),
    summaryParsing: (data: StepPayloadType) => summaryParsing(data),
    summaryPDFParsing: (data: StepPayloadType) => summaryPDFParsing(data),
  }),
  evidences: SECTION_2_EVIDENCES
};

// Logic.
function runtimeRules(steps: WizardStepType[], data: StepPayloadType, currentStep: number | 'summary'): void {

  steps.splice(1);

  if (data.hasEvidence === 'NOT_YET') {

    steps.push(
      new FormEngineModel({
        parameters: [{
          id: 'currentlyCollectingEvidence', dataType: 'radio-group', label: stepsLabels.q2.label,
          validations: { isRequired: [true, 'Choose one option'] },
          items: yesNoItems
        }]
      })
    );

    if (data.currentlyCollectingEvidence === 'YES') {

      steps.push(
        new FormEngineModel({
          parameters: [{
            id: 'summaryOngoingEvidenceGathering', dataType: 'textarea', label: stepsLabels.q3.label, description: stepsLabels.q3.description,
            validations: { isRequired: [true, 'A description is required'] },
            lengthLimit: 'largeDown'
          }]
        }),
        new FormEngineModel({
          parameters: [{
            id: 'files', dataType: 'file-upload', label: stepsLabels.q4.label, description: stepsLabels.q4.description,
            validations: { isRequired: [true, 'Upload at least one file'] }
          }]
        })
      );

    } else {
      delete data.summaryOngoingEvidenceGathering;
      delete data.files;
    }

    steps.push(
      new FormEngineModel({
        parameters: [{
          id: 'needsSupportAnyArea', dataType: 'checkbox-array', label: stepsLabels.q5.label,
          validations: { isRequired: [true, 'Choose at least one item'] },
          items: needsSupportAnyAreaItems
        }]
      })
    );

  } else {

    delete data.currentlyCollectingEvidence;
    delete data.summaryOngoingEvidenceGathering;
    delete data.needsSupportAnyArea;

  }

}

function outboundParsing(data: StepPayloadType): OutboundPayloadType {

  return {
    hasEvidence: data.hasEvidence,
    currentlyCollectingEvidence: data.currentlyCollectingEvidence,
    summaryOngoingEvidenceGathering: data.summaryOngoingEvidenceGathering,
    files: data.files?.map(item => item.id),
    needsSupportAnyArea: data.needsSupportAnyArea,
    evidences: data.evidences
  };

}


function summaryParsing(data: StepPayloadType): WizardSummaryType[] {

  const toReturn: WizardSummaryType[] = [];

  let editStepNumber = 1;

  toReturn.push({
    label: stepsLabels.q1.label,
    value: yesNotYetItems.find(item => item.value === data.hasEvidence)?.label,
    editStepNumber: editStepNumber++
  });


  if (data.hasEvidence === 'NOT_YET') {

    toReturn.push({
      label: stepsLabels.q2.label,
      value: yesNoItems.find(item => item.value === data.currentlyCollectingEvidence)?.label,
      editStepNumber: editStepNumber++
    });

    if (data.currentlyCollectingEvidence === 'YES') {

      toReturn.push({
        label: stepsLabels.q3.label,
        value: data.summaryOngoingEvidenceGathering,
        editStepNumber: editStepNumber++
      });

      const stepNumber = editStepNumber++
      const allFiles = (data.files || []).map(item => ({ id: item.id, name: item.name, url: item.url }));
      allFiles.forEach((item, i) => {
        toReturn.push({
          label: `Attachment ${i + 1}`,
          value: `<a href='${item.url}'>${item.name}</a>` || 'Unknown',
          editStepNumber: stepNumber,
          allowHTML: true,
          isFile: true
        });
      });

    }

    toReturn.push({
      label: stepsLabels.q5.label,
      value: data.needsSupportAnyArea?.map(v => needsSupportAnyAreaItems.find(item => item.value === v)?.label).join('\n'),
      editStepNumber: editStepNumber++
    });

  }

  data.evidences?.forEach((item, i) => {
    toReturn.push({
      label: `Evidence ${i + 1}`,
      value: item.description || evidenceSubmitTypeItems.find(e => e.value === item.evidenceSubmitType)?.label,
      evidenceId: i
    });
  });

  return toReturn;

}

function summaryPDFParsing(data: StepPayloadType): WizardSummaryType[] {
  return summaryParsing(data);
}
