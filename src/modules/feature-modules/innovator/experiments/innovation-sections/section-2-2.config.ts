import { FormEngineModel, WizardEngineModel, WizardStepType, WizardSummaryType } from '@modules/shared/forms';
import { InnovationSectionEnum } from '@modules/stores/innovation/innovation.enums';
import { InnovationSectionConfigType } from '@modules/stores/innovation/innovation.models';
import { yesNoItems } from '@modules/stores/innovation/sections/catalogs.config';

import { evidenceNeedSupportItems, hasEvidenceItems } from './catalog.config';

import { clinicalEvidenceItems, SECTION_2_EVIDENCES } from './section-2-2-evidences.config';


// Labels.
const stepsLabels = {
  q1: 'Do you have any evidence to show the impact or benefits of your innovation?',
  q2: 'Are you currently collecting evidence, or have plans to collect evidence?',
  q3: {
    label: 'Write a short summary of your ongoing or planned evidence gathering, including the IRAS number if known.',
    description: `An IRAS ID is a unique identifier, which is generated by IRAS when you first create a project. It is the accepted common study identifier, allowing research to be traced across its study lifecycle. For more information visit the <a href="https://www.myresearchproject.org.uk" target="_blank" rel="noopener noreferrer">IRAS website (opens in new window)</a>.`
  },
  q4: {
    label: 'Upload any documents relevant to this evidence collection',
    description: 'The files must be CSV, XLSX, DOCX or PDF, and can be up to 20MB.'
  },
  q5: 'Do you need support with any of these areas?'
};


// Types.
type BaseType = {
  hasEvidence: null | 'YES' | 'NOT_YET',
  currentlyCollectingEvidence: null | 'YES' | 'NO',
  summaryOngoingEvidenceGathering: null | string,
  files: { id: string, displayFileName: string, url: string }[],
  needsSupportAnyArea: [],
  evidences: {
    id: string,
    evidenceType: 'CLINICAL' | 'ECONOMIC' | 'OTHER',
    clinicalEvidenceType: null | 'DATA_PUBLISHED' | 'NON_RANDOMISED_COMPARATIVE_DATA' | 'NON_RANDOMISED_NON_COMPARATIVE_DATA' | 'CONFERENCE' | 'RANDOMISED_CONTROLLED_TRIAL' | 'UNPUBLISHED_DATA' | 'OTHER',
    description: string,
    summary: string
  }[];
};
type InboundPayloadType = BaseType;
type StepPayloadType = BaseType;
type OutboundPayloadType = BaseType;


export const SECTION_2_2: InnovationSectionConfigType['sections'][0] = {
  id: InnovationSectionEnum.EVIDENCE_OF_EFFECTIVENESS,
  title: 'Evidence of effectiveness',
  wizard: new WizardEngineModel({
    steps: [
      new FormEngineModel({
        parameters: [{
          id: 'hasEvidence',
          dataType: 'radio-group',
          label: stepsLabels.q1,
          description: 'Evidence of effectiveness can include clinical and economic effectiveness as well as other proven benefits such as staff and system benefits. You\'ll be able to add several pieces of evidence one at a time. We will ask about user testing and regulatory approval (approvals by government or health authorities) in later sections.',
          validations: { isRequired: [true, 'Choose one option'] },
          items: hasEvidenceItems
        }]
      })
    ],
    showSummary: true,
    runtimeRules: [(steps: WizardStepType[], currentValues: StepPayloadType, currentStep: number | 'summary') => runtimeRules(steps, currentValues, currentStep)],
    inboundParsing: (data: InboundPayloadType) => inboundParsing(data),
    outboundParsing: (data: StepPayloadType) => outboundParsing(data),
    summaryParsing: (data: StepPayloadType) => summaryParsing(data),
    summaryPDFParsing: (data: StepPayloadType) => summaryPDFParsing(data),
  }),
  evidences: SECTION_2_EVIDENCES
};


function runtimeRules(steps: WizardStepType[], data: StepPayloadType, currentStep: number | 'summary'): void {

  steps.splice(1);

  if (data.hasEvidence === 'NOT_YET') {

    steps.push(
      new FormEngineModel({
        parameters: [{
          id: 'currentlyCollectingEvidence',
          dataType: 'radio-group',
          label: stepsLabels.q2,
          validations: { isRequired: [true, 'Choose one option'] },
          items: yesNoItems
        }]
      })
    );

    if (data.currentlyCollectingEvidence === 'YES') {
      steps.push(
        new FormEngineModel({
          parameters: [{
            id: 'summaryOngoingEvidenceGathering',
            dataType: 'textarea',
            label: stepsLabels.q3.label,
            description: stepsLabels.q3.description,
            validations: { isRequired: [true, 'A description is required'] },
            lengthLimit: 'largeDown'
          }]
        }),
        new FormEngineModel({
          parameters: [{
            id: 'files',
            dataType: 'file-upload',
            label: stepsLabels.q4.label,
            description: stepsLabels.q4.description,
            validations: { isRequired: [true, 'Upload at least one file'] }
          }],
        })
      );
    } else {
      data.summaryOngoingEvidenceGathering = null;
      data.files = [];
    }

    steps.push(
      new FormEngineModel({
        parameters: [{
          id: 'needsSupportAnyArea',
          dataType: 'checkbox-array',
          label: stepsLabels.q5,
          validations: { isRequired: [true, 'Choose at least one item'] },
          items: evidenceNeedSupportItems
        }]
      })
    );

  } else {
    data.currentlyCollectingEvidence = null;
    data.summaryOngoingEvidenceGathering = null;
    data.needsSupportAnyArea = []
  }

}


function inboundParsing(data: InboundPayloadType): StepPayloadType {

  return {
    hasEvidence: data.hasEvidence ?? null,
    currentlyCollectingEvidence: data.currentlyCollectingEvidence ?? null,
    summaryOngoingEvidenceGathering: data.summaryOngoingEvidenceGathering ?? null,
    files: data.files ?? [],
    needsSupportAnyArea: data.needsSupportAnyArea ?? [],
    evidences: data.evidences ?? [],
  };

}

function outboundParsing(data: StepPayloadType): OutboundPayloadType {

  return {
    hasEvidence: data.hasEvidence,
    currentlyCollectingEvidence: data.currentlyCollectingEvidence,
    summaryOngoingEvidenceGathering: data.summaryOngoingEvidenceGathering,
    files: data.files,
    needsSupportAnyArea: data.needsSupportAnyArea,
    evidences: data.evidences,
  };

}


function summaryParsing(data: StepPayloadType): WizardSummaryType[] {

  const toReturn: WizardSummaryType[] = [];

  toReturn.push({
    label: stepsLabels.q1,
    value: hasEvidenceItems.find(item => item.value === data.hasEvidence)?.label,
    editStepNumber: 1
  });


  if (data.hasEvidence === 'NOT_YET') {

    toReturn.push({
      label: stepsLabels.q2,
      value: yesNoItems.find(item => item.value === data.currentlyCollectingEvidence)?.label,
      editStepNumber: toReturn.length + 1
    });

    if (data.currentlyCollectingEvidence === 'YES') {

      toReturn.push({
        label: stepsLabels.q3.label,
        value: data.summaryOngoingEvidenceGathering,
        editStepNumber: toReturn.length + 1
      });

      const stepNumber = toReturn.length + 1;
      const allFiles = (data.files || []).map((item: any) => ({ id: item.id, name: item.name || item.displayFileName, url: item.url }));
      allFiles.forEach((item, i) => {
        toReturn.push({
          label: `Attachment ${i + 1}`,
          value: `<a href='${item.url}'>${item.name}</a>` || 'Unknown',
          editStepNumber: stepNumber,
          allowHTML: true,
          isFile: true
        });
      });

    }

    toReturn.push({
      label: stepsLabels.q5,
      value: data.needsSupportAnyArea?.map(iten => evidenceNeedSupportItems.find(item => item.value === iten)?.label).join('\n'),
      editStepNumber: 1
    });

  }

  (data.evidences || []).forEach((item, i) => {
    toReturn.push({
      label: `Evidence ${i + 1}`,
      value: item.description || clinicalEvidenceItems.find(e => e.value === item.clinicalEvidenceType)?.label,
      evidenceId: i
    });
  });

  return toReturn;

}

function summaryPDFParsing(data: StepPayloadType): WizardSummaryType[] {
  return summaryParsing(data);
}
